{"version":3,"file":"prediction-models-QEREKywz.js","sources":["../../src/api/client.js","../../src/logic/ich-volume-calculator.js"],"sourcesContent":["/**\n * Medical Prediction API Client - Refactored for Enterprise Architecture\n * Eliminates code duplication using BasePredictionClient patterns\n *\n * Key improvements:\n * - Single source of truth for API logic\n * - Consistent error handling across all endpoints\n * - DRY principle enforcement\n * - Enhanced medical validation\n * - Enterprise-grade logging and monitoring\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\nimport { API_URLS, APP_CONFIG, DEV_CONFIG } from '../config.js';\nimport { extractDriversFromResponse, extractProbabilityFromResponse, extractConfidenceFromResponse } from './drivers.js';\nimport { lvoProbability, lvoClass } from '../lib/lvoModel.js';\n\n// APIError class for medical API errors\nexport class APIError extends Error {\n  constructor(message, status, url) {\n    super(message);\n    this.name = 'APIError';\n    this.status = status;\n    this.url = url;\n  }\n}\n\n// MedicalAPIError class (same as APIError for compatibility)\nexport class MedicalAPIError extends APIError {\n  constructor(message, status, url) {\n    super(message, status, url);\n    this.name = 'MedicalAPIError';\n  }\n}\n\n// Helper function to format drivers from flat dictionary\nfunction formatDriversFromDict(drivers, predictionType) {\n  if (!drivers || typeof drivers !== 'object') return null;\n\n  const positive = [];\n  const negative = [];\n\n  Object.entries(drivers).forEach(([label, weight]) => {\n    if (typeof weight === 'number') {\n      if (weight > 0) {\n        positive.push({ label, weight });\n      } else if (weight < 0) {\n        negative.push({ label, weight: Math.abs(weight) });\n      }\n    }\n  });\n\n  // Sort by weight (descending)\n  positive.sort((a, b) => b.weight - a.weight);\n  negative.sort((a, b) => b.weight - a.weight);\n\n  return {\n    kind: 'flat_dictionary',\n    units: 'logit',\n    positive,\n    negative,\n    meta: {},\n  };\n}\n\n// Helper functions to replace basePredictionClient functionality\nconst clientHelpers = {\n  safeParseFloat: (value, defaultValue = 0) => {\n    const parsed = parseFloat(value);\n    return isNaN(parsed) ? defaultValue : parsed;\n  },\n\n  normalizeBooleans: (payload) => {\n    const normalized = { ...payload };\n    Object.keys(normalized).forEach(key => {\n      if (normalized[key] === 'true' || normalized[key] === true) {\n        normalized[key] = 1;\n      } else if (normalized[key] === 'false' || normalized[key] === false) {\n        normalized[key] = 0;\n      }\n    });\n    return normalized;\n  },\n\n  async makeApiCall(endpoint, payload, endpointType = 'unknown') {\n    console.log(`[API] Making ${endpointType} request to:`, endpoint);\n    console.log(`[API] Payload:`, payload);\n\n    try {\n      const controller = new AbortController();\n      const timeout = endpoint.includes('full_stroke') ? 15000 : 8000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const normalizedPayload = this.normalizeBooleans(payload);\n\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n        body: JSON.stringify(normalizedPayload),\n        signal: controller.signal,\n        mode: 'cors'\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => 'Network error');\n        throw new MedicalAPIError(\n          `API request failed: ${response.status} ${response.statusText} - ${errorText}`,\n          response.status,\n          endpoint\n        );\n      }\n\n      const result = await response.json();\n      console.log(`[API] ${endpointType} response:`, result);\n      console.log(`[API] ${endpointType} response keys:`, Object.keys(result));\n      console.log(`[API] ${endpointType} first key:`, Object.keys(result)[0]);\n      console.log(`[API] ${endpointType} first value:`, result[Object.keys(result)[0]]);\n      console.log(`[API] ${endpointType} probability:`, result.probability);\n      console.log(`[API] ${endpointType} ich_probability:`, result.ich_probability);\n\n      // Normalize response: some APIs return \"ich_probability\" instead of \"probability\"\n      if (!result.probability && result.ich_probability !== undefined) {\n        result.probability = result.ich_probability;\n        console.log(`[API] ${endpointType} normalized probability from ich_probability:`, result.probability);\n      }\n\n      return result;\n\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.warn(`[API] ${endpointType} request timeout`);\n        throw new MedicalAPIError(`Request timeout after ${timeout/1000}s`, 408, endpoint);\n      }\n\n      if (error instanceof MedicalAPIError) {\n        throw error;\n      }\n\n      console.error(`[API] ${endpointType} request failed:`, error);\n      throw new MedicalAPIError(\n        `Network error: ${error.message}`,\n        0,\n        endpoint\n      );\n    }\n  },\n\n  getRequestStats: () => ({ requests: 0, errors: 0, avgResponseTime: 0 }),\n  cancelAllRequests: () => console.log('Cancel requests - not implemented'),\n\n  async predict(moduleType, payload) {\n    const endpointMap = {\n      'coma_ich': API_URLS.COMA_ICH,\n      'limited_ich': API_URLS.LDM_ICH,\n      'full_stroke': API_URLS.FULL_STROKE,\n      'lvo': API_URLS.LVO_PREDICTION\n    };\n\n    const endpoint = endpointMap[moduleType];\n    if (!endpoint) {\n      throw new MedicalAPIError(`Unknown module type: ${moduleType}`, 400, 'unknown');\n    }\n\n    return await this.makeApiCall(endpoint, payload, moduleType);\n  }\n};\n\n/**\n * Warm up Google Cloud Functions on app load\n * Optimized for production reliability\n */\nexport async function warmUpFunctions() {\n  console.log('Warming up Cloud Functions...');\n\n  const prioritizedUrls = [\n    API_URLS.FULL_STROKE,      // Warm this first - most complex\n    API_URLS.LVO_PREDICTION,   // New LVO endpoint\n    API_URLS.COMA_ICH,\n    API_URLS.LDM_ICH,\n    API_URLS.AUTHENTICATE\n  ];\n\n  const warmUpPromises = prioritizedUrls.map(async (url, index) => {\n    await new Promise(resolve => setTimeout(resolve, index * 200));\n\n    try {\n      const controller = new AbortController();\n      const timeout = url.includes('full_stroke') ? 8000 : 3000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({}),\n        signal: controller.signal,\n        mode: 'cors'\n      });\n\n      clearTimeout(timeoutId);\n      console.log(`‚úì Warmed up: ${url.split('/').pop()}`);\n    } catch (error) {\n      console.log(`‚úì Warm-up attempt for ${url.split('/').pop()} completed`);\n    }\n  });\n\n  Promise.all(warmUpPromises).then(() => {\n    console.log('‚úÖ Cloud Functions warm-up complete');\n  }).catch(() => {\n    // Silently handle errors\n  });\n}\n\n/**\n * COMA ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for coma module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictComaIch(payload) {\n  try {\n    return await clientHelpers.predict('coma_ich', payload);\n  } catch (error) {\n    // Transform MedicalAPIError back to APIError for backward compatibility\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = 'APIError';\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * Limited Data ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for limited data module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictLimitedIch(payload) {\n  try {\n    return await clientHelpers.predict('limited_ich', payload);\n  } catch (error) {\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = 'APIError';\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * LVO Prediction with Enhanced Fallback Logic\n * @param {Object} payload - Patient data for LVO assessment\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} LVO prediction result\n */\nexport async function predictLVO(payload, retryCount = 0) {\n  console.log('[API] predictLVO called with payload:', payload);\n\n  if (!payload.gfap_value || !payload.fast_ed_score) {\n    throw new MedicalAPIError(\n      'Missing required parameters: gfap_value and fast_ed_score',\n      400,\n      API_URLS.LVO_PREDICTION\n    );\n  }\n\n  console.log('[API] LVO payload preparation...');\n\n  try {\n    // Try enterprise client first\n    console.log('üå©Ô∏è Using LVO Cloud Function (primary)');\n    const result = await clientHelpers.predict('lvo', payload);\n    console.log('[API] LVO Cloud Function response:', result);\n    return result;\n\n  } catch (error) {\n    console.warn('‚ö†Ô∏è LVO Cloud Function failed, falling back to local model:', error.message);\n    console.log('üè† Using New LVO Model (fallback)');\n\n    try {\n      const gfapValue = parseFloat(payload.gfap_value);\n      const fastEdScore = parseInt(payload.fast_ed_score);\n\n      if (isNaN(gfapValue) || isNaN(fastEdScore)) {\n        throw new Error('Invalid GFAP or FAST-ED values');\n      }\n\n      const probability = lvoProbability(gfapValue, fastEdScore);\n      const classification = lvoClass(gfapValue, fastEdScore);\n\n      const drivers = {\n        kind: 'new_model_fallback',\n        units: 'normalized_contribution',\n        positive: [\n          { label: 'GFAP Biomarker', weight: gfapValue > 100 ? 0.6 : 0.3 },\n          { label: 'FAST-ED Score', weight: fastEdScore * 0.1 }\n        ].sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)),\n        negative: [],\n        meta: {\n          riskLevel: probability > 0.7 ? 'high' : probability > 0.4 ? 'moderate' : 'low',\n          interpretation: `${(probability * 100).toFixed(1)}% LVO probability (${classification === 1 ? 'Positive' : 'Negative'})`\n        }\n      };\n\n      return {\n        probability,\n        drivers,\n        confidence: probability > 0.7 ? 0.9 : probability > 0.4 ? 0.7 : 0.5,\n        module: 'New LVO Model (Scientifically Calibrated)',\n        interpretation: `${(probability * 100).toFixed(1)}% LVO probability based on GFAP=${gfapValue} and FAST-ED=${fastEdScore}`\n      };\n\n    } catch (localError) {\n      console.warn('‚ö†Ô∏è New LVO Model fallback failed:', localError.message);\n      throw new MedicalAPIError(\n        `LVO prediction failed: ${error.message}`,\n        error.status || 500,\n        API_URLS.LVO_PREDICTION\n      );\n    }\n  }\n}\n\n/**\n * Full Stroke Prediction - Enhanced with Enterprise Patterns\n * @param {Object} payload - Complete patient data\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} Complete stroke assessment\n */\nexport async function predictFullStroke(payload, retryCount = 0) {\n  console.log('[API] predictFullStroke called with payload:', payload);\n  console.log('[API] isLocalPreview():', isLocalPreview());\n\n  try {\n    // Get ICH prediction using enterprise client\n    const fullStrokeResponse = await clientHelpers.predict('full_stroke', payload);\n    console.log('[API] Full stroke raw response:', fullStrokeResponse);\n\n    // Extract ICH data from nested structure\n    const ichResult = fullStrokeResponse.ich_prediction || {};\n    console.log('[API] Extracted ICH data:', ichResult);\n\n    // Get LVO prediction using enhanced LVO function\n    let lvoResult = null;\n    try {\n      console.log('üîÑ Using dedicated LVO prediction (cloud function + fallback)');\n      lvoResult = await predictLVO(payload);\n      console.log('‚úÖ LVO prediction successful via dedicated function');\n    } catch (lvoError) {\n      console.warn('‚ö†Ô∏è Dedicated LVO prediction failed:', lvoError);\n\n      // Fallback: try to extract LVO from full stroke response if available\n      if (ichResult.lvo_prediction) {\n        lvoResult = {\n          probability: ichResult.lvo_prediction.probability || 0,\n          drivers: ichResult.lvo_prediction.drivers || null,\n          confidence: ichResult.lvo_prediction.confidence || 0.8,\n          module: 'Full Stroke (API Fallback)'\n        };\n      } else {\n        // Final fallback to local LVO model\n        lvoResult = await predictLVO(payload);\n      }\n    }\n\n    return {\n      ich: {\n        probability: ichResult.probability,\n        drivers: ichResult.drivers ? formatDriversFromDict(ichResult.drivers, 'ICH') : ichResult.drivers,\n        confidence: ichResult.confidence,\n        module: ichResult.module\n      },\n      lvo: lvoResult\n    };\n\n  } catch (error) {\n    console.error('Full Stroke prediction failed:', error);\n\n    if (error.status === 408 && retryCount < 1) {\n      console.log('‚è±Ô∏è Retrying Full Stroke API (cold start detected)...');\n      return predictFullStroke(payload, retryCount + 1);\n    }\n\n    // Use local preview fallback for development\n    if (isLocalPreview()) {\n      const mockData = DEV_CONFIG.mockApiResponses.full_stroke;\n      const ichPrediction = mockData.ich_prediction || {};\n      const lvoPrediction = mockData.lvo_prediction || {};\n\n      return {\n        ich: {\n          probability: clientHelpers.safeParseFloat(ichPrediction.probability, 0),\n          drivers: ichPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(ichPrediction.confidence, 0.85),\n          module: 'Full Stroke (Mock)'\n        },\n        lvo: {\n          probability: clientHelpers.safeParseFloat(lvoPrediction.probability, 0),\n          drivers: lvoPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(lvoPrediction.confidence, 0.85),\n          module: 'Full Stroke (Mock)'\n        }\n      };\n    }\n\n    throw new MedicalAPIError(\n      `Failed to get stroke predictions: ${error.message}`,\n      error.status,\n      API_URLS.FULL_STROKE\n    );\n  }\n}\n\n/**\n * Helper function to check if running in local preview\n * @returns {boolean} True if local preview environment\n */\nfunction isLocalPreview() {\n  return ['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname);\n}\n\n/**\n * Re-export utility functions for backward compatibility\n */\nexport const normalizeBooleans = (payload) => clientHelpers.normalizeBooleans(payload);\nexport const safeParseFloat = (value, defaultValue) => clientHelpers.safeParseFloat(value, defaultValue);\n\n/**\n * Get API client statistics for monitoring\n * @returns {Object} Client statistics\n */\nexport function getClientStats() {\n  return clientHelpers.getRequestStats();\n}\n\n/**\n * Cancel all active API requests\n */\nexport function cancelAllRequests() {\n  clientHelpers.cancelAllRequests();\n}","/**\n * ICH Volume Calculation and Clinical Assessment\n * Based on validated log-log regression model (R¬≤ = 0.476)\n * Formula: log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)\n *\n * @typedef {import('../types/medical-types.js').ICHVolumeResult} ICHVolumeResult\n * @typedef {import('../types/medical-types.js').ValidationResult} ValidationResult\n */\n\n// Bulletproof error handling utilities\nimport {\n  safeAsync,\n  safeMedicalCalculation,\n  MedicalError,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  MEDICAL_ERROR_CODES,\n  validateMedicalInputs\n} from '../utils/error-handler.js';\n\n// Type safety utilities\nimport { TypeChecker, MEDICAL_CONSTANTS } from '../types/medical-types.js';\n\n// Professional logging\nimport { medicalLogger, LOG_CATEGORIES } from '../utils/medical-logger.js';\n\n// Volume-based risk thresholds with clinical significance\nexport const VOLUME_THRESHOLDS = {\n  low: {\n    max: 10, color: '#dc2626', label: 'Small', severity: 'low',\n  },\n  moderate: {\n    min: 10, max: 20, color: '#dc2626', label: 'Moderate', severity: 'moderate',\n  },\n  high: {\n    min: 20, max: 30, color: '#dc2626', label: 'Large', severity: 'high',\n  },\n  critical: {\n    min: 30, color: '#dc2626', label: 'Critical', severity: 'critical',\n  },\n};\n\n// 30-day mortality rates by hemorrhage volume (based on clinical literature)\n// Calibrated to Broderick et al. (1993) landmark study:\n// - 30ml = 19% mortality\n// - 60ml = 91% mortality\n// With correlation strengths from observational data\n// Reference thresholds for documentation purposes:\nexport const MORTALITY_BY_VOLUME = {\n  '<10ml': '5-10%', // Minor hemorrhage\n  '10-30ml': '10-19%', // Small (Broderick: 30ml=19%)\n  '30-50ml': '19-44%', // Moderate (interpolated)\n  '50-60ml': '44-91%', // Large (Broderick: 60ml=91%)\n  '‚â•60ml': '91-100%', // Massive (Broderick: >60ml=91-100%)\n};\n\n/**\n * Calculate ICH volume from GFAP biomarker value with bulletproof error handling\n * @param {number} gfapValue - GFAP value in pg/ml (29-10,001)\n * @returns {Promise<ICHVolumeResult>} Volume calculation results with type safety\n */\nexport async function calculateICHVolume(gfapValue) {\n  return safeMedicalCalculation(\n    async (inputs) => {\n      const { gfap } = inputs;\n\n      medicalLogger.info('ICH volume calculation started', {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        operation: 'ich_volume_calculation'\n      });\n\n      // Type safety validation first\n      TypeChecker.ensureType(gfap, 'number', 'GFAP value');\n      TypeChecker.ensureRange(gfap, MEDICAL_CONSTANTS.GFAP_RANGE, 'GFAP value');\n\n      // Validate medical input\n      const validation = validateMedicalInputs(\n        { gfap },\n        {\n          gfap: {\n            required: true,\n            type: 'number',\n            min: 0,\n            max: 10001,\n            warningMin: 29,\n            warningMax: 10000\n          }\n        }\n      );\n\n      if (!validation.isValid) {\n        throw new MedicalError(\n          validation.errors[0]?.message || 'Invalid GFAP value',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ validationErrors: validation.errors, gfapValue: gfap });\n      }\n\n      // Handle edge cases\n      if (!gfap || gfap <= 0) {\n        return {\n          volume: 0,\n          volumeRange: { min: 0, max: 0 },\n          riskLevel: 'low',\n          mortalityRate: '~0%',\n          isValid: true,\n          calculation: 'No hemorrhage detected',\n          warnings: []\n        };\n      }\n\n      // Cap extremely high GFAP values\n      const cappedGfap = Math.min(gfap, 10000);\n      const warnings = [];\n      if (gfap > 10000) {\n        warnings.push(`GFAP value ${gfap} exceeds maximum calculation range and was capped at 10,000 pg/ml`);\n      }\n\n      // Values above 10,000 pg/ml are capped for calculation stability\n      if (cappedGfap !== gfap) {\n        warnings.push('GFAP value was adjusted for calculation stability');\n      }\n\n      // Apply log-log regression formula with error checking\n      if (cappedGfap <= 0) {\n        throw new MedicalError(\n          'GFAP value must be positive for volume calculation',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ gfapValue: cappedGfap });\n      }\n\n      const logGfap = Math.log10(cappedGfap);\n      if (!isFinite(logGfap)) {\n        throw new MedicalError(\n          'Invalid logarithm calculation for GFAP value',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ gfapValue: cappedGfap, logValue: logGfap });\n      }\n\n      const logVolume = 0.0192 + 0.4533 * logGfap;\n      if (!isFinite(logVolume)) {\n        throw new MedicalError(\n          'Invalid volume calculation result',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ logGfap, logVolume });\n      }\n\n      const calculatedVolume = 10 ** logVolume;\n      if (!isFinite(calculatedVolume) || calculatedVolume < 0) {\n        throw new MedicalError(\n          'Calculated volume is invalid',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ logVolume, calculatedVolume });\n      }\n\n      // Calculate confidence range (¬±30%)\n      const volumeRange = {\n        min: calculatedVolume * 0.7,\n        max: calculatedVolume * 1.3,\n      };\n\n      // Determine risk level based on volume\n      const riskLevel = getVolumeRiskLevel(calculatedVolume);\n\n      // Get mortality rate\n      const mortalityRate = getMortalityRate(calculatedVolume);\n\n      // Format volume for display\n      const displayVolume = calculatedVolume < 1 ? '<1' : calculatedVolume.toFixed(1);\n\n      // Safety check for extreme values\n      if (calculatedVolume > 200) {\n        warnings.push('Calculated volume is extremely high - please verify GFAP measurement');\n      }\n\n      /** @type {ICHVolumeResult} */\n      const result = {\n        volume: calculatedVolume,\n        confidence: 0.476, // R¬≤ of the regression model\n        volumeCategory: getVolumeCategory(calculatedVolume),\n        timestamp: new Date().toISOString(),\n        // Legacy properties for backward compatibility\n        displayVolume,\n        volumeRange: {\n          min: volumeRange.min.toFixed(1),\n          max: volumeRange.max.toFixed(1),\n        },\n        riskLevel,\n        mortalityRate,\n        isValid: true,\n        calculation: `Based on GFAP ${gfap} pg/ml`,\n        threshold: calculatedVolume >= 30 ? 'SURGICAL' : calculatedVolume >= 20 ? 'HIGH_RISK' : 'MANAGEABLE',\n        warnings,\n        metadata: {\n          originalGfap: gfap,\n          cappedGfap,\n          calculationTimestamp: new Date().toISOString()\n        }\n      };\n\n      // Validate final result\n      if (typeof result.volume !== 'number' || !isFinite(result.volume)) {\n        medicalLogger.error('ICH volume calculation result validation failed', {\n          category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n          gfapValue: gfap,\n          resultVolume: result.volume,\n          resultType: typeof result.volume\n        });\n        throw new MedicalError(\n          'Final volume calculation result is invalid',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.CRITICAL\n        ).withContext({ result });\n      }\n\n      medicalLogger.info('ICH volume calculation completed successfully', {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        calculatedVolume: result.volume,\n        volumeCategory: result.volumeCategory,\n        riskLevel: result.riskLevel,\n        confidence: result.confidence\n      });\n\n      return result;\n    },\n    { gfap: gfapValue },\n    {\n      timeout: 5000,\n      fallback: (error) => ({\n        volume: 0,\n        volumeRange: { min: 0, max: 0 },\n        riskLevel: 'low',\n        mortalityRate: 'Calculation unavailable',\n        isValid: false,\n        calculation: 'Calculation error - using fallback',\n        error: error.message,\n        fallbackUsed: true,\n        warnings: ['Volume calculation failed - fallback values used']\n      }),\n      context: {\n        operation: 'ich_volume_calculation',\n        gfapValue,\n        formula: 'log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)'\n      }\n    }\n  );\n}\n\n/**\n * Fast synchronous volume estimate for UI rendering\n * Mirrors the main formula without async/error wrappers.\n * @param {number} gfap\n * @returns {number} estimated volume in ml (>= 0)\n */\nexport function estimateVolumeFromGFAP(gfap) {\n  try {\n    const v = Math.max(0, 10 ** (0.0192 + 0.4533 * Math.log10(Math.max(1, Math.min(gfap, 10000)))));\n    return Number.isFinite(v) ? v : 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Estimate mortality band from volume (synchronous, display-only)\n * @param {number} volume\n * @returns {string}\n */\nexport function estimateMortalityFromVolume(volume) {\n  if (!Number.isFinite(volume) || volume <= 0) return '5-10%';\n  if (volume >= 60) return '91-100%';\n  if (volume >= 50) return '44-91%';\n  if (volume >= 30) return '19-44%';\n  if (volume >= 10) return '10-19%';\n  return '5-10%';\n}\n\n/**\n * Determine risk level based on calculated volume with safety checks\n * @param {number} volume - Calculated volume in ml\n * @returns {string} Risk level key\n */\nfunction getVolumeRiskLevel(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== 'number' || !isFinite(volume)) {\n      throw new MedicalError(\n        'Invalid volume for risk level calculation',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      throw new MedicalError(\n        'Volume cannot be negative',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM\n      ).withContext({ volume });\n    }\n\n    if (volume >= VOLUME_THRESHOLDS.critical.min) {\n      return 'critical';\n    }\n    if (volume >= VOLUME_THRESHOLDS.high.min) {\n      return 'high';\n    }\n    if (volume >= VOLUME_THRESHOLDS.moderate.min) {\n      return 'moderate';\n    }\n    return 'low';\n  } catch (error) {\n    // Fallback to 'low' for safety\n    console.warn('Risk level calculation failed, defaulting to low:', error.message);\n    return 'low';\n  }\n}\n\n/**\n * Get mortality rate based on volume with improved interpolation and safety checks\n * Calibrated to match clinical studies (Broderick 1993: 30ml=19%, 60ml=91%)\n * @param {number} volume - Volume in ml\n * @returns {string} Mortality rate string with citation\n */\nfunction getMortalityRate(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== 'number' || !isFinite(volume)) {\n      throw new MedicalError(\n        'Invalid volume for mortality rate calculation',\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      return 'Invalid volume';\n    }\n\n    // For very small hemorrhages\n    if (volume < 10) {\n      return '5-10%‚Å¥';\n    }\n\n    // For small hemorrhages (10-30ml)\n    // Broderick: 30ml = 19% mortality\n    if (volume < 30) {\n      // Linear interpolation: 10ml=10%, 30ml=19%\n      const rate = Math.round(10 + (volume - 10) * (19 - 10) / (30 - 10));\n      // Validate interpolated rate\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%‚Å¥`;\n    }\n\n    // For moderate hemorrhages (30-50ml)\n    // Interpolating from Broderick 30ml=19% to 50ml‚âà44%\n    if (volume < 50) {\n      // Linear interpolation: 30ml=19%, 50ml=44%\n      const rate = Math.round(19 + (volume - 30) * (44 - 19) / (50 - 30));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬≥`;\n    }\n\n    // For large hemorrhages (50-60ml)\n    // Broderick: 60ml = 91% mortality\n    if (volume < 60) {\n      // Steeper increase: 50ml=44%, 60ml=91%\n      const rate = Math.round(44 + (volume - 50) * (91 - 44) / (60 - 50));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬≤`;\n    }\n\n    // For massive hemorrhages (‚â•60ml)\n    // Broderick: >60ml = 91-100%\n    if (volume < 80) {\n      // 60ml=91%, 80ml=96%\n      const rate = Math.round(91 + (volume - 60) * (96 - 91) / (80 - 60));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          'Calculated mortality rate out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬π`;\n    }\n\n    // For extreme cases (‚â•80ml)\n    return '96-100%¬π';\n  } catch (error) {\n    // Fallback for safety\n    console.warn('Mortality rate calculation failed:', error.message);\n    return 'Rate unavailable';\n  }\n}\n\n/**\n * Calculate hemorrhage size percentage for visualization with safety checks\n * Based on brain area scaling: 30ml = ~40% of brain area, 100ml = ~70%\n * @param {number} volume - Volume in ml\n * @returns {Promise<number>} Percentage of brain area (0-70)\n */\nexport async function calculateHemorrhageSizePercent(volume) {\n  return safeAsync(\n    async () => {\n      // Input validation\n      if (typeof volume !== 'number' || !isFinite(volume)) {\n        throw new MedicalError(\n          'Invalid volume for size percentage calculation',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM\n        ).withContext({ volume, type: typeof volume });\n      }\n\n      if (volume < 0) {\n        throw new MedicalError(\n          'Volume cannot be negative for visualization',\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM\n        ).withContext({ volume });\n      }\n\n      if (volume <= 0) {\n        return 0;\n      }\n      if (volume >= 100) {\n        return 70;\n      } // Maximum 70% of brain area\n\n      // Non-linear scaling for realistic appearance\n      // 30ml = 40%, 100ml = 70%\n      const sqrtValue = Math.sqrt(volume / 30);\n      if (!isFinite(sqrtValue)) {\n        throw new MedicalError(\n          'Invalid square root calculation for visualization',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM\n        ).withContext({ volume, sqrtValue });\n      }\n\n      const basePercent = sqrtValue * 40;\n      const result = Math.min(basePercent, 70);\n\n      // Final validation\n      if (!isFinite(result) || result < 0 || result > 100) {\n        throw new MedicalError(\n          'Calculated percentage out of valid range',\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM\n        ).withContext({ volume, basePercent, result });\n      }\n\n      return result;\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 1000,\n      fallback: () => {\n        // Safe fallback based on simple linear scaling\n        if (volume <= 0) return 0;\n        if (volume >= 100) return 70;\n        return Math.min((volume / 100) * 70, 70);\n      },\n      context: {\n        operation: 'hemorrhage_size_calculation',\n        volume\n      }\n    }\n  );\n}\n\n/**\n * Get color for volume visualization\n * @param {number} volume - Volume in ml\n * @returns {string} CSS color value\n */\nexport function getVolumeColor(volume) {\n  const riskLevel = getVolumeRiskLevel(volume);\n  return VOLUME_THRESHOLDS[riskLevel].color;\n}\n\n/**\n * Test function for validation with comprehensive error handling\n * Tests the calculator with known GFAP values\n */\nexport async function testVolumeCalculator() {\n  return safeAsync(\n    async () => {\n      const testCases = [\n        { gfap: 100, expectedVolume: '~5ml' },\n        { gfap: 500, expectedVolume: '~15ml' },\n        { gfap: 1000, expectedVolume: '~21ml' },\n        { gfap: 1500, expectedVolume: '~28ml' },\n        { gfap: 3000, expectedVolume: '~50ml' },\n        { gfap: 5000, expectedVolume: '~72ml' },\n      ];\n\n      // ICH Volume Calculator Test Results\n      const results = await Promise.allSettled(\n        testCases.map(async (test) => {\n          try {\n            const result = await calculateICHVolume(test.gfap);\n            return { gfap: test.gfap, result, expected: test.expectedVolume, success: true };\n          } catch (error) {\n            return {\n              gfap: test.gfap,\n              result: null,\n              expected: test.expectedVolume,\n              success: false,\n              error: error.message\n            };\n          }\n        })\n      );\n\n      // Process results and handle any failures\n      const processedResults = results.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        } else {\n          return {\n            gfap: testCases[index].gfap,\n            result: null,\n            expected: testCases[index].expectedVolume,\n            success: false,\n            error: result.reason?.message || 'Test failed'\n          };\n        }\n      });\n\n      const successfulTests = processedResults.filter(r => r.success).length;\n      const totalTests = testCases.length;\n\n      return {\n        results: processedResults,\n        summary: {\n          total: totalTests,\n          successful: successfulTests,\n          failed: totalTests - successfulTests,\n          successRate: `${Math.round((successfulTests / totalTests) * 100)}%`\n        },\n        timestamp: new Date().toISOString()\n      };\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 10000,\n      fallback: (error) => ({\n        results: [],\n        summary: {\n          total: 0,\n          successful: 0,\n          failed: 0,\n          successRate: '0%'\n        },\n        error: error.message,\n        timestamp: new Date().toISOString()\n      }),\n      context: {\n        operation: 'volume_calculator_test'\n      }\n    }\n  );\n}\n\n/**\n * Get volume category according to medical type definitions\n * @param {number} volume - Volume in ml\n * @returns {'small'|'moderate'|'large'|'massive'} Volume category\n */\nfunction getVolumeCategory(volume) {\n  try {\n    // Type safety validation\n    TypeChecker.ensureType(volume, 'number', 'volume for categorization');\n\n    if (volume < 0) {\n      throw new TypeError('Volume cannot be negative for categorization');\n    }\n\n    const thresholds = MEDICAL_CONSTANTS.VOLUME_THRESHOLDS;\n\n    if (volume < thresholds.SMALL) {\n      return 'small';\n    }\n    if (volume < thresholds.MODERATE) {\n      return 'moderate';\n    }\n    if (volume < thresholds.LARGE) {\n      return 'large';\n    }\n    return 'massive';\n  } catch (error) {\n    // Fallback to 'small' for safety\n    return 'small';\n  }\n}\n\n/**\n * Format volume for display with appropriate precision\n * @param {number} volume - Volume in ml\n * @returns {string} Formatted volume string\n */\nexport function formatVolumeDisplay(volume) {\n  if (volume < 1) {\n    return '<1 ml';\n  }\n  if (volume < 10) {\n    return `${volume.toFixed(1)} ml`;\n  }\n  return `${Math.round(volume)} ml`;\n}\n"],"names":["APIError","message","status","url","MedicalAPIError","formatDriversFromDict","drivers","predictionType","positive","negative","label","weight","a","b","clientHelpers","value","defaultValue","parsed","payload","normalized","key","endpoint","endpointType","controller","timeout","timeoutId","normalizedPayload","response","errorText","result","error","moduleType","API_URLS","predictComaIch","apiError","predictLimitedIch","predictLVO","retryCount","gfapValue","fastEdScore","probability","lvoProbability","classification","lvoClass","localError","predictFullStroke","isLocalPreview","fullStrokeResponse","ichResult","lvoResult","lvoError","mockData","DEV_CONFIG","ichPrediction","lvoPrediction","estimateVolumeFromGFAP","gfap","v","e","estimateMortalityFromVolume","volume","formatVolumeDisplay"],"mappings":"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"}