/**
 * Clinical Reporting System Test Suite
 * Medical-Grade Report Generation and Compliance Testing
 */

import {
  ClinicalReportGenerator,
  ClinicalReport,
  ReportType,
  ReportFormat,
  DeliveryMethod,
  QualityMetrics,
  OutcomePredictor,
  ReportValidationError
} from '../../analytics/clinical-reporting.js';

// Mock dependencies
jest.mock('jspdf', () => ({
  jsPDF: jest.fn().mockImplementation(() => ({
    text: jest.fn(),
    addPage: jest.fn(),
    save: jest.fn(),
    output: jest.fn().mockReturnValue('mock-pdf-data')
  }))
}));

jest.mock('html2canvas', () => jest.fn().mockResolvedValue({
  toDataURL: jest.fn().mockReturnValue('data:image/png;base64,mock-canvas-data')
}));

describe('ClinicalReportGenerator', () => {
  let reportGenerator;
  let mockAuditTrail;
  let mockPatientData;

  beforeEach(() => {
    mockAuditTrail = {
      logReportGeneration: jest.fn(),
      logReportDelivery: jest.fn(),
      logDataAccess: jest.fn()
    };

    mockPatientData = {
      patientId: 'PT12345',
      demographics: {
        age: 65,
        gender: 'M',
        medicalRecordNumber: 'MRN789'
      },
      strokeAssessment: {
        timestamp: new Date('2025-01-15T10:30:00Z'),
        nihssScore: 8,
        gfapLevel: 150.5,
        riskScore: 0.75,
        recommendation: 'thrombolysis'
      },
      clinicalData: {
        vitalSigns: {
          bloodPressure: '160/90',
          heartRate: 85,
          oxygenSaturation: 98
        },
        symptoms: ['aphasia', 'hemiparesis', 'facial_droop'],
        onsetTime: new Date('2025-01-15T08:00:00Z')
      }
    };

    reportGenerator = new ClinicalReportGenerator({
      auditTrail: mockAuditTrail,
      templates: {
        header: 'Clinical Report Template',
        footer: 'Generated by iGFAP Stroke Triage Assistant'
      },
      branding: {
        logo: 'data:image/png;base64,mock-logo',
        institution: 'Medical Center',
        department: 'Emergency Department'
      }
    });
  });

  describe('Initialization', () => {
    test('should initialize with default configuration', () => {
      const defaultGenerator = new ClinicalReportGenerator();

      expect(defaultGenerator.config.outputDirectory).toBe('./reports');
      expect(defaultGenerator.config.retentionDays).toBe(2555); // 7 years
      expect(defaultGenerator.qualityMetrics).toBeDefined();
    });

    test('should initialize with custom configuration', () => {
      expect(reportGenerator.config.templates.header).toBe('Clinical Report Template');
      expect(reportGenerator.config.branding.institution).toBe('Medical Center');
      expect(reportGenerator.auditTrail).toBe(mockAuditTrail);
    });
  });

  describe('Report Type Generation', () => {
    test('should generate clinical summary report', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          includeCharts: true,
          includeMedicalHistory: true
        }
      );

      expect(report).toBeInstanceOf(ClinicalReport);
      expect(report.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(report.format).toBe(ReportFormat.HTML);
      expect(report.content).toContain('Clinical Summary');
      expect(report.content).toContain(mockPatientData.patientId);
      expect(report.metadata.patientId).toBe('PT12345');
    });

    test('should generate outcome prediction report', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.OUTCOME_PREDICTION,
        mockPatientData,
        {
          format: ReportFormat.PDF,
          predictionModels: ['stroke_severity', 'functional_outcome'],
          confidenceInterval: 0.95
        }
      );

      expect(report.type).toBe(ReportType.OUTCOME_PREDICTION);
      expect(report.format).toBe(ReportFormat.PDF);
      expect(report.content).toContain('Outcome Prediction');
      expect(report.predictions).toBeDefined();
      expect(report.predictions.length).toBeGreaterThan(0);
    });

    test('should generate risk assessment report', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.RISK_ASSESSMENT,
        mockPatientData,
        {
          format: ReportFormat.JSON,
          riskFactors: ['age', 'nihss', 'gfap_level'],
          includeRecommendations: true
        }
      );

      expect(report.type).toBe(ReportType.RISK_ASSESSMENT);
      expect(report.riskAnalysis).toBeDefined();
      expect(report.riskAnalysis.totalRisk).toBe(0.75);
      expect(report.recommendations).toBeDefined();
    });

    test('should generate decision support report', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.DECISION_SUPPORT,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          includeClinicalGuidelines: true,
          includeEvidenceBase: true
        }
      );

      expect(report.type).toBe(ReportType.DECISION_SUPPORT);
      expect(report.clinicalGuidelines).toBeDefined();
      expect(report.evidenceBase).toBeDefined();
      expect(report.recommendations).toContain('thrombolysis');
    });

    test('should generate quality metrics report', async () => {
      const qualityData = {
        doorToNeedleTime: 45, // minutes
        accuracyMetrics: { sensitivity: 0.92, specificity: 0.88 },
        patientOutcomes: { goodOutcome: 0.78 },
        adherenceToProtocols: 0.95
      };

      const report = await reportGenerator.generateReport(
        ReportType.QUALITY_METRICS,
        qualityData,
        {
          format: ReportFormat.CSV,
          period: { start: '2025-01-01', end: '2025-01-31' },
          includeComparisons: true
        }
      );

      expect(report.type).toBe(ReportType.QUALITY_METRICS);
      expect(report.metrics).toBeDefined();
      expect(report.metrics.doorToNeedleTime).toBe(45);
    });

    test('should generate comprehensive report', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.COMPREHENSIVE,
        mockPatientData,
        {
          format: ReportFormat.PDF,
          sections: ['summary', 'assessment', 'predictions', 'quality'],
          includeAppendices: true
        }
      );

      expect(report.type).toBe(ReportType.COMPREHENSIVE);
      expect(report.sections).toContain('summary');
      expect(report.sections).toContain('assessment');
      expect(report.sections).toContain('predictions');
      expect(report.content.length).toBeGreaterThan(1000); // Comprehensive content
    });
  });

  describe('Report Formatting', () => {
    test('should format report as HTML', async () => {
      const htmlReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.CLINICAL_SUMMARY,
        ReportFormat.HTML
      );

      expect(htmlReport.content).toContain('<html>');
      expect(htmlReport.content).toContain('<head>');
      expect(htmlReport.content).toContain('<body>');
      expect(htmlReport.content).toContain('Clinical Summary');
      expect(htmlReport.mimeType).toBe('text/html');
    });

    test('should format report as PDF', async () => {
      const pdfReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.CLINICAL_SUMMARY,
        ReportFormat.PDF
      );

      expect(pdfReport.content).toBe('mock-pdf-data');
      expect(pdfReport.mimeType).toBe('application/pdf');
      expect(pdfReport.fileName).toMatch(/\.pdf$/);
    });

    test('should format report as JSON', async () => {
      const jsonReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.RISK_ASSESSMENT,
        ReportFormat.JSON
      );

      const parsedContent = JSON.parse(jsonReport.content);
      expect(parsedContent).toHaveProperty('patientId');
      expect(parsedContent).toHaveProperty('riskScore');
      expect(jsonReport.mimeType).toBe('application/json');
    });

    test('should format report as CSV', async () => {
      const qualityData = {
        metrics: [
          { name: 'door_to_needle_time', value: 45, unit: 'minutes' },
          { name: 'accuracy', value: 0.92, unit: 'percentage' }
        ]
      };

      const csvReport = await reportGenerator.formatReport(
        qualityData,
        ReportType.QUALITY_METRICS,
        ReportFormat.CSV
      );

      expect(csvReport.content).toContain('name,value,unit');
      expect(csvReport.content).toContain('door_to_needle_time,45,minutes');
      expect(csvReport.mimeType).toBe('text/csv');
    });
  });

  describe('Report Customization', () => {
    test('should apply custom templates', async () => {
      const customTemplate = {
        header: 'Custom Hospital Header',
        patientSection: '<div class="patient-info">{{patientData}}</div>',
        footer: 'Custom Footer with Disclaimer'
      };

      reportGenerator.addTemplate('custom_summary', customTemplate);

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          template: 'custom_summary',
          format: ReportFormat.HTML
        }
      );

      expect(report.content).toContain('Custom Hospital Header');
      expect(report.content).toContain('Custom Footer with Disclaimer');
    });

    test('should include custom branding', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        { format: ReportFormat.HTML }
      );

      expect(report.content).toContain('Medical Center');
      expect(report.content).toContain('Emergency Department');
      expect(report.content).toContain('mock-logo');
    });

    test('should support custom styling', async () => {
      const customStyles = {
        primaryColor: '#2c5aa0',
        secondaryColor: '#f8f9fa',
        fontFamily: 'Arial, sans-serif',
        logoPosition: 'top-right'
      };

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          customStyles
        }
      );

      expect(report.content).toContain('#2c5aa0');
      expect(report.content).toContain('Arial, sans-serif');
    });
  });

  describe('Data Validation and Security', () => {
    test('should validate required patient data', async () => {
      const incompleteData = {
        patientId: 'PT12345'
        // Missing required fields
      };

      await expect(
        reportGenerator.generateReport(
          ReportType.CLINICAL_SUMMARY,
          incompleteData
        )
      ).rejects.toThrow(ReportValidationError);
    });

    test('should sanitize sensitive data in reports', async () => {
      const sensitiveData = {
        ...mockPatientData,
        demographics: {
          ...mockPatientData.demographics,
          ssn: '123-45-6789',
          insuranceNumber: 'INS987654'
        }
      };

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        sensitiveData,
        {
          format: ReportFormat.HTML,
          sanitizePII: true
        }
      );

      expect(report.content).not.toContain('123-45-6789');
      expect(report.content).not.toContain('INS987654');
      expect(report.content).toContain('[REDACTED]');
    });

    test('should validate report permissions', async () => {
      const restrictedUser = {
        userId: 'nurse123',
        role: 'nurse',
        permissions: ['view_basic_reports']
      };

      await expect(
        reportGenerator.generateReport(
          ReportType.COMPREHENSIVE,
          mockPatientData,
          {
            requestedBy: restrictedUser,
            validatePermissions: true
          }
        )
      ).rejects.toThrow('Insufficient permissions');
    });

    test('should log report generation events', async () => {
      await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData
      );

      expect(mockAuditTrail.logReportGeneration).toHaveBeenCalledWith(
        expect.objectContaining({
          reportType: ReportType.CLINICAL_SUMMARY,
          patientId: 'PT12345'
        })
      );
    });
  });

  describe('Quality Metrics Integration', () => {
    test('should calculate door-to-needle time metrics', () => {
      const timestamps = {
        arrivalTime: new Date('2025-01-15T08:00:00Z'),
        tpaAdministration: new Date('2025-01-15T08:42:00Z')
      };

      const metrics = reportGenerator.calculateDoorToNeedleTime(timestamps);
      expect(metrics.doorToNeedleMinutes).toBe(42);
      expect(metrics.meetsBenchmark).toBe(true); // < 60 minutes
    });

    test('should calculate model accuracy metrics', () => {
      const predictions = [
        { predicted: 0.8, actual: 1, threshold: 0.5 },
        { predicted: 0.3, actual: 0, threshold: 0.5 },
        { predicted: 0.7, actual: 1, threshold: 0.5 },
        { predicted: 0.2, actual: 0, threshold: 0.5 }
      ];

      const metrics = reportGenerator.calculateAccuracyMetrics(predictions);
      expect(metrics.accuracy).toBe(1.0);
      expect(metrics.sensitivity).toBe(1.0);
      expect(metrics.specificity).toBe(1.0);
    });

    test('should generate quality improvement recommendations', () => {
      const qualityData = {
        doorToNeedleTime: 75, // Exceeds benchmark
        accuracy: 0.85,
        protocolAdherence: 0.88
      };

      const recommendations = reportGenerator.generateQualityRecommendations(qualityData);

      expect(recommendations).toContain('door-to-needle time');
      expect(recommendations.length).toBeGreaterThan(0);
    });
  });

  describe('Automated Report Delivery', () => {
    test('should configure email delivery', () => {
      const emailConfig = {
        method: DeliveryMethod.EMAIL,
        recipients: ['physician@hospital.com', 'director@hospital.com'],
        subject: 'Clinical Report - Patient PT12345',
        schedule: 'immediate'
      };

      reportGenerator.configureDelivery(emailConfig);
      expect(reportGenerator.deliveryConfig.method).toBe(DeliveryMethod.EMAIL);
      expect(reportGenerator.deliveryConfig.recipients.length).toBe(2);
    });

    test('should configure secure file transfer', () => {
      const sftpConfig = {
        method: DeliveryMethod.SECURE_TRANSFER,
        endpoint: 'sftp://secure.hospital.com',
        credentials: 'encrypted_key',
        directory: '/clinical_reports',
        encryption: 'AES-256'
      };

      reportGenerator.configureDelivery(sftpConfig);
      expect(reportGenerator.deliveryConfig.method).toBe(DeliveryMethod.SECURE_TRANSFER);
      expect(reportGenerator.deliveryConfig.encryption).toBe('AES-256');
    });

    test('should deliver report via configured method', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData
      );

      const deliveryResult = await reportGenerator.deliverReport(report);

      expect(deliveryResult.success).toBe(true);
      expect(deliveryResult.deliveryId).toBeDefined();
      expect(mockAuditTrail.logReportDelivery).toHaveBeenCalled();
    });

    test('should handle delivery failures gracefully', async () => {
      // Mock delivery failure
      const failingGenerator = new ClinicalReportGenerator({
        deliveryConfig: {
          method: DeliveryMethod.EMAIL,
          recipients: ['invalid@email'],
          failOnError: false
        }
      });

      const report = await failingGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData
      );

      const deliveryResult = await failingGenerator.deliverReport(report);

      expect(deliveryResult.success).toBe(false);
      expect(deliveryResult.error).toBeDefined();
    });
  });

  describe('Scheduled Reporting', () => {
    test('should schedule daily quality reports', () => {
      const schedule = {
        reportType: ReportType.QUALITY_METRICS,
        frequency: 'daily',
        time: '06:00',
        recipients: ['quality@hospital.com'],
        parameters: {
          period: 'last_24_hours',
          includeComparisons: true
        }
      };

      const scheduledReport = reportGenerator.scheduleReport(schedule);

      expect(scheduledReport.id).toBeDefined();
      expect(scheduledReport.nextRun).toBeInstanceOf(Date);
      expect(scheduledReport.frequency).toBe('daily');
    });

    test('should schedule weekly comprehensive reports', () => {
      const schedule = {
        reportType: ReportType.COMPREHENSIVE,
        frequency: 'weekly',
        dayOfWeek: 'monday',
        time: '08:00',
        recipients: ['administration@hospital.com']
      };

      const scheduledReport = reportGenerator.scheduleReport(schedule);

      expect(scheduledReport.frequency).toBe('weekly');
      expect(scheduledReport.dayOfWeek).toBe('monday');
    });

    test('should execute scheduled reports', async () => {
      const mockScheduledReport = {
        id: 'sched123',
        reportType: ReportType.QUALITY_METRICS,
        parameters: { period: 'last_7_days' },
        lastRun: null
      };

      const executionResult = await reportGenerator.executeScheduledReport(mockScheduledReport);

      expect(executionResult.success).toBe(true);
      expect(executionResult.reportId).toBeDefined();
      expect(mockScheduledReport.lastRun).toBeInstanceOf(Date);
    });
  });

  describe('Report Archival and Retention', () => {
    test('should archive completed reports', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData
      );

      const archiveResult = await reportGenerator.archiveReport(report);

      expect(archiveResult.archived).toBe(true);
      expect(archiveResult.archiveLocation).toBeDefined();
      expect(archiveResult.retentionUntil).toBeInstanceOf(Date);
    });

    test('should enforce retention policies', async () => {
      const expiredReports = await reportGenerator.getExpiredReports();
      const purgeResult = await reportGenerator.purgeExpiredReports();

      expect(Array.isArray(expiredReports)).toBe(true);
      expect(purgeResult.purgedCount).toBeGreaterThanOrEqual(0);
    });

    test('should maintain audit trail for archived reports', async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData
      );

      await reportGenerator.archiveReport(report);

      expect(mockAuditTrail.logDataAccess).toHaveBeenCalledWith(
        expect.objectContaining({
          action: 'archive',
          resourceType: 'clinical_report'
        })
      );
    });
  });
});

describe('ClinicalReport', () => {
  let sampleReport;

  beforeEach(() => {
    sampleReport = new ClinicalReport({
      id: 'RPT12345',
      type: ReportType.CLINICAL_SUMMARY,
      format: ReportFormat.HTML,
      patientId: 'PT12345',
      generatedBy: 'physician123',
      content: '<html><body>Sample Report</body></html>',
      metadata: {
        version: '1.0',
        timestamp: new Date(),
        dataSource: 'stroke_triage_system'
      }
    });
  });

  describe('Report Properties', () => {
    test('should have required properties', () => {
      expect(sampleReport.id).toBe('RPT12345');
      expect(sampleReport.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(sampleReport.format).toBe(ReportFormat.HTML);
      expect(sampleReport.patientId).toBe('PT12345');
      expect(sampleReport.content).toContain('Sample Report');
    });

    test('should generate unique report IDs', () => {
      const report1 = new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY });
      const report2 = new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY });

      expect(report1.id).not.toBe(report2.id);
    });

    test('should track generation timestamp', () => {
      expect(sampleReport.generatedAt).toBeInstanceOf(Date);
      expect(sampleReport.generatedAt.getTime()).toBeLessThanOrEqual(Date.now());
    });
  });

  describe('Report Validation', () => {
    test('should validate required fields', () => {
      expect(() => new ClinicalReport({})).toThrow('Report type is required');
      expect(() => new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY }))
        .not.toThrow();
    });

    test('should validate content format', () => {
      const invalidReport = new ClinicalReport({
        type: ReportType.CLINICAL_SUMMARY,
        format: ReportFormat.JSON,
        content: 'invalid json content'
      });

      expect(() => invalidReport.validateContent()).toThrow('Invalid JSON content');
    });
  });

  describe('Report Serialization', () => {
    test('should serialize to JSON', () => {
      const json = sampleReport.toJSON();

      expect(json.id).toBe('RPT12345');
      expect(json.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(json.generatedAt).toBe(sampleReport.generatedAt.toISOString());
    });

    test('should create report from JSON', () => {
      const json = sampleReport.toJSON();
      const restoredReport = ClinicalReport.fromJSON(json);

      expect(restoredReport.id).toBe(sampleReport.id);
      expect(restoredReport.type).toBe(sampleReport.type);
      expect(restoredReport.content).toBe(sampleReport.content);
    });
  });
});

describe('OutcomePredictor', () => {
  let predictor;

  beforeEach(() => {
    predictor = new OutcomePredictor({
      models: ['functional_outcome', 'mortality_risk', 'length_of_stay'],
      confidenceThreshold: 0.8
    });
  });

  describe('Prediction Models', () => {
    test('should predict functional outcomes', () => {
      const patientData = {
        age: 65,
        nihssScore: 8,
        strokeType: 'ischemic',
        treatmentReceived: 'thrombolysis'
      };

      const prediction = predictor.predictFunctionalOutcome(patientData);

      expect(prediction).toHaveProperty('mrsScore');
      expect(prediction).toHaveProperty('confidence');
      expect(prediction).toHaveProperty('factors');
    });

    test('should predict mortality risk', () => {
      const patientData = {
        age: 80,
        nihssScore: 15,
        comorbidities: ['atrial_fibrillation', 'diabetes']
      };

      const prediction = predictor.predictMortalityRisk(patientData);

      expect(prediction.risk).toBeGreaterThan(0);
      expect(prediction.risk).toBeLessThanOrEqual(1);
      expect(prediction.riskCategory).toBeDefined();
    });

    test('should predict length of stay', () => {
      const patientData = {
        age: 70,
        nihssScore: 5,
        strokeSeverity: 'minor'
      };

      const prediction = predictor.predictLengthOfStay(patientData);

      expect(prediction.days).toBeGreaterThan(0);
      expect(prediction.range).toHaveProperty('min');
      expect(prediction.range).toHaveProperty('max');
    });
  });

  describe('Prediction Validation', () => {
    test('should validate prediction confidence', () => {
      const lowConfidencePrediction = {
        outcome: 'good',
        confidence: 0.6
      };

      const isReliable = predictor.validatePrediction(lowConfidencePrediction);
      expect(isReliable).toBe(false); // Below 0.8 threshold
    });

    test('should provide uncertainty quantification', () => {
      const prediction = predictor.predictFunctionalOutcome({
        age: 65,
        nihssScore: 8
      });

      expect(prediction.uncertainty).toBeDefined();
      expect(prediction.uncertainty.type).toBeDefined();
      expect(prediction.uncertainty.range).toBeDefined();
    });
  });
});

describe('Report Integration', () => {
  test('should integrate with audit trail system', async () => {
    const mockAuditTrail = {
      logReportGeneration: jest.fn(),
      logDataAccess: jest.fn()
    };

    const generator = new ClinicalReportGenerator({
      auditTrail: mockAuditTrail
    });

    await generator.generateReport(
      ReportType.CLINICAL_SUMMARY,
      { patientId: 'PT12345' }
    );

    expect(mockAuditTrail.logReportGeneration).toHaveBeenCalled();
  });

  test('should integrate with quality metrics system', async () => {
    const generator = new ClinicalReportGenerator();

    const qualityReport = await generator.generateReport(
      ReportType.QUALITY_METRICS,
      {
        metrics: {
          doorToNeedleTime: 45,
          accuracy: 0.92
        }
      }
    );

    expect(qualityReport.type).toBe(ReportType.QUALITY_METRICS);
    expect(qualityReport.qualityScore).toBeDefined();
  });
});